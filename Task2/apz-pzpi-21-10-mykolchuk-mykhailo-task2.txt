1 ОПИС АРХІТЕКТУРИ СИСТЕМИ

Розрахунок коефіцієнта якості водіння автомобіля передбачає високу відмовостійкість, масштабованість, швидкість обробки великого об’єму даних, тому що така предметна область може налічувати мільйони користувачів одночасно. Виходячи з цих вимог була спроектована система яка відповідає всім переліченим критеріям.
Почнемо з опису бази даних. У якості СУБД, було обрано реляційну базу даних MS SQL Server. Даний тип баз даних було обрано через те, що вони дозволяють побудувати стійкі залежності між даними за допомогою таблиць, що сприяє цілісності даних та забезпеченню транзакційної безпеки. СУБД MS SQL Server підтримується компанією Microsoft, що означає що вона має велику спільноту користувачів, багату документацію та постійні покращення функціоналу. Загалом MS SQL Server це дуже популярне рішення в Enterprise розробці.
Серверна частина побудована за допомогою модульної платформи для розробки програмного забезпечення .Net. Фреймворк для написання веб-застосунків ASP.Net Core є найшвидшим  з точки зору швидкості виконання коду серед усіх своїх конкурентів. До того ж платформа .Net гарно інтегрована з вищеописаною СУБД MS SQL Server, бо це продукти однієї компанії, що робить .Net ще більш привабливим вибором.
Для обробки величезних потоків подій від автомобілів в реальному часі використовується розподілене сховище подій і платформа для їх багатопотокового оброблення Apache Kafka. В основі концепції Kafka лежить абстракція «набір повідомлень», яка передбачає групування повідомлення разом, щоб зменшити накладні витрати на транспортування по мережі. Це призводить до більших мережевих пакетів, більших послідовних операцій на диску та неперервних блоків пам'яті, що дозволяє Kafka перетворювати хаотичний потік випадкових повідомлень на лінійні записи. Таким чином забезпечується надвисока швидкість передачі даних.
До того ж Kafka відмовостійка, бо дозволяє налаштовувати реплікації даних на різні брокери в кластері, і масштабована, бо передбачає горизонтальне масштабування. Таким чином, Apache Kafka це ідеальний варіант для обробки та зберігання нескінченних потоків подій, вона дуже часто використовується в системах, шо працюють з IoT пристроями.
Клієнтська частина написана за допомогою популярного фреймворку мови JavaScript - Angular. Він часто зустрічається в парі з серверною частиною на .Net.
Мобільний застосунок написаний на мові нативного програмування під Android - Kotlin. Це сучасний підхід до розробки Android застосунків, бо Kotlin дозволяє писати меньше коду ніж Java для однакового функціоналу, при цьому якість коду залишається високою.

2 ПОБУДОВА ДІАГРАМИ РОЗГОРТАННЯ

Діаграма розгортання ілюструє спосіб розташування елементів чи компонентів системи на апаратному забезпеченні та їх взаємодію. За допомогою цієї діаграми інженери та розробники можуть отримати уявлення про те, як програмне забезпечення взаємодіє з обладнанням і визначити вимоги до виконавчого середовища. Діаграму розгортання наведено на рисунку 3. 
Back-end, Front-end та база даних системи розташовані в приватній віртуальній мережі Google Cloud Platform. Це забезпечує максимальну можливу швидкість взаємодії цих частин системи між собою та безпеку даних, що між ними передаються, тому що ці частини системи спілкуються між собою всередині мережі Google, не виходячи в публічний Інтернет простір. Back-end та база даних мають тільки приватні IP-адреси, що не дозволяє звернутися до них ззовні.
В якості СУБД використовується Microsoft SQL Server. Це популярна в Enterprise розробці та надійна в використанні СУБД.
В якості платформи для розробки Backend частини використовується фреймворк ASP.Net Core, мова програмування C#. Backend частина являє собою API, до якого звертаються всі інші частини системи. Доступ до бази даних відбувається за допомогою об'єктно-реляційної проекції Entity Framework Core.
Кластер платформи потокової передачі подій Apache Kafka взаємодіє з серверною частиною та датчиком у автомобілі за допомогою власного двійкового протоколу, працюючого на основі TCP протоколу. Це дозволяє миттєво передавати величезні об’єми даних.
Датчик у автомобілі являє собою Raspberry pi одноплатний комп'ютер з встановленою на нього середою виконання CLR. Це дозволяє спростити розробку і використовувати мову програмування C#, а не більш складні мови, такі як C або C++.  
Веб-частина використовує фреймворк Angular, який взаємодіє з серверною частиною за допомогою REST API. До неї можна звернутися з будь-якого пристрою, що має встановлений браузер та доступ до Інтернету.
Мобільний застосунок розроблено за допомогою мови нативного програмування для Android - Kotlin. Застосунок можливо завантажити на будь-який пристрій під операційною системою Android. З серверною частиною він взаємодію через HTTPS запити.

3 ОПИС АРХІТЕКТУРИ СЕРВЕРНОЇ ЧАСТИНИ

Серверна частина програмної системи є фундаментом для всіх інших частин. Mobile частина, клієнтська частина а також розумний пристрій – всі взаємодіють з серверної частиною, обмін даних проходить через неї, основні розрахунки та бізнес-логіка системи також припадають на неї.
Серверна частина побудована за допомогою модульної платформи для розробки програмного забезпечення .Net. Фреймворк для написання веб-застосунків ASP.Net Core є найшвидшим  з точки зору швидкості виконання коду серед усіх своїх конкурентів. До того ж платформа .Net гарно інтегрована з вищеописаною СУБД MS SQL Server, бо це продукти однієї компанії, що робить .Net ще більш привабливим вибором.
Серверна частина відповідає за всю бізнес-логіку програмної системи та побудована на основі принципів чистої архітектури. Основна ідея цієї архітектури полягає в поділі системи на окремі рівні абстракції, що дозволяє забезпечити високу масштабованість, зручність тестування і підтримки, а також зменшити залежність між компонентами. Серверна частина складається з кількох шарів: ядро (містить сутності застосунку – моделі даних), інфраструктура (включає імплементацію бізнес-логіки та функції обробки даних), представлення (містить інтерфейс користувача або API, через який користувач взаємодіє з сервером).

4 ПОБУДОВА ДІАГРАМИ ПРЕЦЕДЕНТІВ

Для опису поведінки системи використовується UML діаграма прецедентів. Загальна діаграма для користувачів наведена на рисунку 1. Вона описує базовий функціонал доступний усім користувачам.
Головним актором системи є «Користувач». Абстрактний «Користувач» містить в собі три більш ситуативні ролі: звичайний користувач, власник компанії та адміністратор. Всі подальші ролі наслідують можливості від «Користувача» і розширюють їх. «Користувач» має можливості реєстрації та подальшого входу в систему, може додавати до системи власні автомобілі, датчики, редагувати свій профіль. Доданий датчик можна під’єднати до автомобіля, це дозволить почати відслідковувати та аналізувати показники водіння людини, яка їздить на цьому автомобілі. Для кожного автомобіля користувач може переглянути історію поїздок та статистику кожної з них.
Актор «Датчик (Smart Device)» представляє собою пристрій, який на фізичному рівні під’єднується до автомобіля, і на програмному рівні встановлює зв’язок між цим автомобілем та датчиком. Протягом поїздки датчик в реальному часі передає дані, зчитані з автомобіля, у спеціальну платформу потокової передачі подій.
Актор «Власник компанії» відрізняється від звичайного користувача тим, що він може мати підлеглих водіїв, додавати їх до системи та налаштовувати зв’язок між ними та доданими автомобілями. Роль звичайного користувача передбачає особисте використання одного або декількох автомобілів без функціоналу підлеглих водіїв. Визначення ролі «Власник компанії» чи «Звичайний користувач» відбувається на етапі реєстрації. 
Актор «Адміністратор» є адміністратором системи. «Адміністратор» має змогу переглядати записи та вносити зміни в базу даних системи, наприклад переглянути всіх зареєстрованих в системі користувачів, їх автомобілі. Також він може отримувати статистику по роботі системи, переглядати логи роботи серверу та кластеру потокової передачі подій.

5 ПОБУДОВА ER-ДІАГРАМИ

ER-модель - модель даних, що дозволяє описувати концептуальні схеми предметної галузі. ER-модель використовується при високорівневому проектуванні бази даних. З її допомогою можна виділити ключові сутності та позначити зв'язки, які можуть встановлюватись між цими сутностями.
ER-модель містить такі сутності:
-	Користувач: Поле «Role» визначає чи є користувач системи звичайним користувачем або адміністратором. Поле «Type» визначає чи є користувач звичайним водієм або власником компанії з підлеглими водіями.
-	Автомобіль: Описує автомобіль, доданий користувачем до системи. Автомобілю можна призначити тільки один датчик і одного або декількох водіїв;
-	Підлеглий водій: Описує водія, якого користувач додав до системи. Водію можна призначити автомобіль, причому тільки один.
-	Датчик: Описує датчик, доданий користувачем до системи. Датчик можна під’єднати до автомобіля. Після цього при поїздці на цьому автомобілі будуть аналізуватися показники поїздки;
-	Звіт: Сутність звіту являє собою сукупність даних, які були розраховані при аналізі поїздки. Сутність містить такі показники як кількість небезпечних поворотів, час роботи двигуна на надвисоких або наднизьких обертах, моменти різкого гальмування;
-	Момент різкого гальмування: Містить в собі дані про те, коли було здійснено гальмування, яка була початкова та кінцева швидкість;
-	Момент роботи двигуна: Фіксує час початку роботи двигуна на високих або низьких обертах, розраховує середню кількість обертів на хвилину в цей проміжок часу.

6 СПЕЦИФІКАЦІЯ REST

REST це архітектурний стиль для створення розподілених веб-систем. Свторімо REST специфікацію для серверної частини програмної системи (див. додаток А). REST специфікація допоможе визначити доступні маршрути, та їх призначення.

7 ПОБУДОВА ДІАГРАМИ КОМПОНЕНТІВ

Створення UML діаграми компонентів (див. рисунок 5) дозволяє промоделювати високорівневу архітектуру системи, ідентифікувати основні компоненти та їх зв’язки.
На діаграмі проілюстровані компоненти та їх залежності:
1)	Компонент акаунта користувача;
2)	Компонент серверної частини застосунку;
3)	Компонент користувача;
4)	Компонент автомобіля;
5)	Компонент датчику;
6)	Компонент підлеглого водія;
7)	Компонент звіту про поїздку;

ВИСНОВКИ

Під час виконання лабораторної роботи було розроблено серверну частини програмної системи, реалізовано бізнес логіку, створено базу даних та кінцеві точки API. Також детально показали структуру системи на UML діаграмі прецедентів, діаграмі розгортання, діаграмі компонентів та ER-моделі даних. Детально обґрунтували вибір прийнятих інженерних рішень.

ДОДАТОК А
Специфікація REST
Контроллер Authorization
POST	api/authorizeUser	Авторизація користувачів
		api/authorizeSubordinate Авторизація підлеглих водіїв
Контроллер Registration	
POST	api/registerUser	Зареєструвати користувача
		api/registerSubordinate	Зареєструвати підлеглого водія
Контроллер User	
GET	User/all	Отримати всіх користувачів
		User/{id}	Отримати користувача по ідентифікатору
POST	User/changeLng	Змінити мову інтерфейсу користувача
PUT	User/Update	Оновити користувача
DELETE	User/Delete	Видалити користувача
Контроллер Car	
GET	Car /all	Отримати всі автомобілі
		Car /{id}	Отримати автомобіль по ідентифікатору
		Car /byOwner	Отримати всі автомобілі користувача
POST	Car/insert	Додати автомобіль
PUT	Car/update	Оновити автомобіль
DELETE	Car/delete	Видалити автомобіль
Контроллер Record	
GET	Record /all	Отримати всі звіти
		Record /{id}	Отримати звіт по ідентифікатору
		Record/byCar	Отримати всі звіти по цьому автомобілю
POST	Record/insert	Додати звіт
DELETE	Record/delete	Видалити звіт
PUT	Record/update	Оновити звіт
Контроллер Sensor	
GET	Sensor/all	Отримати всі датчики
		Sensor/{id}	Отримати датчик по ідентифікатору
		Sensor/byOwner	Отримати всі датчики відповідного користувача
		Sensor/freeByOwner	Отримати всі непід’єднані до автомобілів датчики відповідного користувача
POST	Sensor/insert	Додати датчик в систему
		Sensor/connectToCar	Під’єднати датчик до автомобіля
		Sensor/disconnectFromCar	Роз’єднати датчик з автомобілем
DELETE	Sensor/delete	Видалити датчик
PUT	Sensor/update	Оновити датчик
Контроллер Subordinate	
GET	Subordinate /all	Отримати всіх підлеглих водіїв
		Subordinate /{id}	Отримати підлеглого водія по ідентифікатору
		Subordinate/byChief	Отримати всіх підлеглих водіїв відповідного користувача
	POST	Subordinate/connectToCar	Додати водія до автомобіля
		Subordinate/disconnectFromCar	Зняти водія з автомобіля
		Subordinate/changeLng	Змінити мову інтерфейсу для водія
	PUT	Subordinate/update	Оновити водія
	DELETE	Subordinate/delete	Видалити водія
